<!doctype html>
<html>
<head>
   <meta charset="utf-8">
   <title>Babylon - Boids</title>
   <style>
        html, body {
         overflow: hidden;
         width: 100%;
         height: 100%;
         margin: 0;
         padding: 0;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .msg{
        	position: absolute;
        	top: 0.5em;
        	left: 0.5em;
        	margin: auto;
        	padding: 0.5em;
        	width: 15%;
        	font-family: courier;
        	color: white;
        	background-color: rgba(0,0,0,0.5);
        	text-align: left;
            overflow-y:;

        }
        .msg>p{
            font-size: 12px;
        }
        #reset{
            font-family: courier;
        	font-size: auto;
        	padding: 0.3em;
            margin-bottom: 0.5em;

        }
        #options{
            display: inline-block;
        	text-align: left;
        	color: black;
        	background-color: rgba(255,255,255,0.2);
        	margin-top: 0.3em;
        	padding: 0.3em;
            font-size: 12px;
        }
        .sliders>p{
        	margin: 0px auto;
            color: black;
        	font-weight: 700;
        }
        #fpsCounter{
        	color: gold;
        	font-weight: 700;
            background-color: rgba(0,0,0,0.5);
            padding: 0.3em;
            margin: 0;
            width: 35%;
        }
        #anchor:hover{
            color: lightgreen;
            cursor: pointer;
        }
        #debug{
            background-color: rgba(255,0,0,0.2);
            text-align: left;
            padding: 0.3em 0.5em;
        }
        #copyright{
            position: absolute;
            bottom: 0;
            right: 0.5em;
            color: white;
            font-family:courier;
            font-size: 12px;
        }
        .checkbox{
            margin: 0.5em;
            vertical-align: top;
        }
   </style>

   <script src="/js/babylon-2.5/dist/babylon.2.5.js"></script>

</head>

<body>

    <p id="copyright">Luca Casini, Alice Valentini, Riccardo Marchi</p>

	<div class="msg">

		<h4>Boids Flocking Simulation</h4>
		<!--<h5>Fisica dei Sistemi Complessi</h5>
        -->
        <p id="fpsCounter"></p>
        <p><a id="anchor" onclick="toggle('options')">show/hide</a> options</p>

        <div id="options">

    		<div class="buttons">
    			<button id="reset">reset size/position</button>
    		</div>

    		<div class="sliders">
    			<p id="size"></p>
    			<input id="slider_SIZE" type="range" min="50" max="1000" step="50" name="size"/>

    			<p id="speed"></p>
    			<input id="slider_SPEED" type="range" min="1" max="5" step="1" />

    			<p id="cohesion"></p>
    			<input id="slider_COH" type="range" min="0.01" max="1" step="0.01" />

    			<p id="alignment"></p>
    			<input id="slider_ALL" type="range" min="0.01" max="1" step="0.01" />

    			<p id="separation"></p>
    			<input id="slider_SEP" type="range" min="0.01" max="1" step="0.01" />

                <input type="checkbox" id="pull" class=".checkbox" onchange="pullSwitch()">inward pull</input>



    		</div>

        </div>

		<!--<div id="debug"></div>-->
	</div>

	<canvas id="renderCanvas"></canvas>

	<script type="text/javascript">
	//COSTANTS
	var SIZE = 50;                  //num boids
    var MAX_DIST2 = Math.pow(250,2);
    var range2 = Math.pow(25,2);
	var speedMultiplyer = 3;
	var cohesionMultiplier = 0.5;
	var allignmentMultiplier = 0.5;
	var separationMultiplier = 0.5;
	var centerpull = false;
    var predators = 4;

    const worldSize = 250;

    var cells = createCells();

    // Get the canvas element from our HTML below
	var canvas = document.querySelector("#renderCanvas");

    // Load the BABYLON 3D engine
	var engine = new BABYLON.Engine(canvas, true);
	var fpsCounter = document.getElementById("fpsCounter");
	var debugText = document.getElementById("debug");

    const allignmentSlider = document.getElementById("slider_ALL");
	allignmentSlider.value = allignmentMultiplier;
	const separationSlider = document.getElementById("slider_SEP");
	separationSlider.value = separationMultiplier;
	const cohesionSlider = document.getElementById("slider_COH");
	cohesionSlider.value = cohesionMultiplier;
	const speedSlider = document.getElementById("slider_SPEED");
	speedSlider.value = speedMultiplyer;
	const sizeSlider = document.getElementById("slider_SIZE");
	sizeSlider.value = SIZE;

    // -------------------------------------------------------------
	// Here begins a function that we will 'call' just after it's built
	var createScene = function () {
        // Now create a basic Babylon Scene object
        var scene = new BABYLON.Scene(engine);
        // Change the scene background color.
        scene.clearColor = new BABYLON.Color3(0, 0.1, 0.1);

        // camera setup
        var camera = new BABYLON.ArcRotateCamera("Camera", 0.7, 1.1 , 800, new BABYLON.Vector3(0, 0, 0), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, false);
        //camera constraints
        camera.lowerBetaLimit = 0.1; //top limit
        camera.upperBetaLimit = (Math.PI / 2) * 1.4; //bottom limit
        // Fog
        //scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
        //scene.fogColor = new BABYLON.Color3(0.8, 0.8, .8);
        //scene.fogDensity = 0.0002;

		// This creates a light, aiming 0,1,0 - to the sky.
        var light = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
		//new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(0, -1, 0), scene);
		//new BABYLON.PointLight("pl", new BABYLON.Vector3(0, 0, 0), scene);
		light.diffuse = new BABYLON.Color3(1,1,1);
		light.groundColor = new BABYLON.Color3.Gray();
        light.intensity = .9;

        /*
        //green material for objectives?
        var greenMaterial = new BABYLON.StandardMaterial("greenMaterial",scene);
        greenMaterial.diffuseColor = BABYLON.Color3.Green();
        greenMaterial.specularColor = BABYLON.Color3.Green();
*/
        //more than 1000 boids = low frame rate!
        boids = [];
        createBoids(scene);
        createPredators(scene);


        // setting for the "bounding" box.
        var box = BABYLON.MeshBuilder.CreateBox("box", {size: worldSize*2, sideOrientation:BABYLON.Mesh.BACKSIDE}, scene);
		boxmat = new BABYLON.StandardMaterial("texture1", scene);
		boxmat.diffuseColor = new BABYLON.Color3(.55,.75,.9)
		box.material =  boxmat;

        //-------------------------------------------------------

        scene.registerBeforeRender(function (){

            //simulation
            updateSpeed(boids);
            updatePosition(boids);

            //interface
            fpsCounter.innerHTML = "FPS: " + engine.getFps().toFixed();
            updateUI();
            speedMultiplyer = document.getElementById("slider_SPEED").value;
            allignmentMultiplier = allignmentSlider.value;
            cohesionMultiplier = cohesionSlider.value;
            separationMultiplier = separationSlider.value;

         });
        //--------------------------------------------------------
        // Leave this function
        return scene;
	}; // End of createScene function

    function updateUI(){
        document.getElementById("size").innerHTML = "size: " + sizeSlider.value;
        document.getElementById("speed").innerHTML = "speed: " + speedSlider.value;
        document.getElementById("cohesion").innerHTML = "cohesion: " + cohesionSlider.value;
        document.getElementById("alignment").innerHTML = "alignment: " + allignmentSlider.value;
        document.getElementById("separation").innerHTML = "separation: " + separationSlider.value;

    }

    function createBoids(scene){
 	        //A material for the noids
            var boidMaterial = new BABYLON.StandardMaterial("sphereMat",scene);
            boidMaterial.diffuseColor = new BABYLON.Color3(.09,.09,.09);
            boidMaterial.specularColor = BABYLON.Color3.Black;
            boidMaterial.ambientColor = new BABYLON.Color3(.9,1,.9);

            for(i = 0; i <SIZE; i++){
            var name = "boid_" + i;
            var boid = BABYLON.MeshBuilder.CreatePolyhedron(name, {type: 0, size: 1, sizeY: 2}, scene);
            boid.material = boidMaterial;

            // Move the boid upward 1/2 its height
            boid.position.x = Math.random() * worldSize - Math.random() * worldSize;
            boid.position.y = Math.random() * worldSize - Math.random() * worldSize;
            boid.position.z = Math.random() * worldSize - Math.random() * worldSize;
            boid.speed = new BABYLON.Vector3(Math.random(),Math.random(),Math.random());
			boid.axis1 = new BABYLON.Vector3.Zero();
			boid.axis3 = new BABYLON.Vector3.Zero();
			boid.rot = BABYLON.Vector3.Zero();
            boid.neighborCount = 0;
            boid.index = spatialHashing(boid.position);
            cells[boid.index].add(boid);

			boids.push(boid);
        }
    }

        function createPredators(scene){
        //red material, for predators
        const redmat = new BABYLON.StandardMaterial("redmat",scene);
        redmat.diffuseColor = BABYLON.Color3.Red();
        redmat.specularColor = BABYLON.Color3.Red();
        for(i = 0; i <predators; i++){
            var predator = BABYLON.MeshBuilder.CreatePolyhedron("predator", {type: 0, size: 1, sizeY: 2}, scene);
            predator.material = redmat;
            //updateBirdGeometry(sphere);

            // Move the sphere upward 1/2 its height
            predator.position.x = Math.random() * 250 - Math.random() * 250;
            predator.position.y = Math.random() * 250 - Math.random() * 250;
            predator.position.z = Math.random() * 250 - Math.random() * 250;
            predator.speed = new BABYLON.Vector3(Math.random(),Math.random(),Math.random());
            predator.axis1 = new BABYLON.Vector3.Zero();
            predator.axis3 = new BABYLON.Vector3.Zero();
            predator.rot = BABYLON.Vector3.Zero();
            predator.index = spatialHashing(predator.position);
            cells[predator.index].add(predator);
            predator.target = new Set();

            boids.push(predator);
        }
    }

	function limitSpeed(bird){
        var limit = speedMultiplyer;
        //moving upwards/downwards is more difficult
        //bird.speed.y *= 0.7;
        if (bird.speed.lengthSquared() > limit){
            bird.speed.normalize();
            if(bird.name=="predator")bird.speed.scaleInPlace(limit*1.5);
            else bird.speed.scaleInPlace(limit);
        }

    }
    function computeNeighborhood(boid){
        var radius = 25;
        var neighborhood = new Set();
        //find the 8 neighborhood cells NE,NW,SE,SW for top and bottom by giving the postion + radius%10 to the spatialhashing function

        //top: +y, north: +z; east:+x
        var TNE=spatialHashing({
            x: clampPosition(boid.position.x + radius),
            y: clampPosition(boid.position.y + radius),
            z: clampPosition(boid.position.z + radius)});
        //top north west
        var TNW=spatialHashing({
            x: clampPosition(boid.position.x - radius),
            y: clampPosition(boid.position.y + radius),
            z: clampPosition(boid.position.z + radius)});
        //top south east
        var TSE=spatialHashing({
            x: clampPosition(boid.position.x + radius),
            y: clampPosition(boid.position.y + radius),
            z: clampPosition(boid.position.z - radius)});
        //top south west
        var TSW=spatialHashing({
            x: clampPosition(boid.position.x - radius),
            y: clampPosition(boid.position.y + radius),
            z: clampPosition(boid.position.z - radius)});
        //bottom north east
        var BNE=spatialHashing({
            x: clampPosition(boid.position.x + radius),
            y: clampPosition(boid.position.y - radius),
            z: clampPosition(boid.position.z + radius)});
        //bottom north west
        var BNW=spatialHashing({
            x: clampPosition(boid.position.x - radius),
            y: clampPosition(boid.position.y - radius),
            z: clampPosition(boid.position.z + radius)});
        //bottom south east
        var BSE=spatialHashing({
            x: clampPosition(boid.position.x + radius),
            y: clampPosition(boid.position.y - radius),
            z: clampPosition(boid.position.z - radius)});
        //bottom south west
        var BSW=spatialHashing({
            x: clampPosition(boid.position.x - radius),
            y: clampPosition(boid.position.y - radius),
            z: clampPosition(boid.position.z - radius)});

        //find nearestNeighbor of each cell in the radius and push it to the neigborhood array that is used for collisions;

        nearestNeighbor(boid, cells[TNE],neighborhood);
        nearestNeighbor(boid, cells[TNW],neighborhood);
        nearestNeighbor(boid, cells[TSE],neighborhood);
        nearestNeighbor(boid, cells[TSW],neighborhood);
        nearestNeighbor(boid, cells[BNE],neighborhood);
        nearestNeighbor(boid, cells[BNW],neighborhood);
        nearestNeighbor(boid, cells[BSE],neighborhood);
        nearestNeighbor(boid, cells[BSW],neighborhood);



        return neighborhood;
    }

    function nearestNeighbor(boid, cell, neighborhood){
        var nearest;
        var nearestDistance = 9999999;
        if(cell.size > 1){
           for(let neighbor of cell){
                if(neighbor.name !== boid.name){
                    var d = BABYLON.Vector3.DistanceSquared(boid.position, neighbor.position)
                    if( d < nearestDistance){
                        nearest = neighbor;
                        nearestDistance = d;
                    }
                }
            }
            neighborhood.add(nearest);
        }
    }

	function updateSpeed(flock){
		//flock.forEach(function(bird){
		for(let bird of flock){
            //initialization
            bird.neighborCount = 0;

            bird.sepVel = BABYLON.Vector3.Zero();
            bird.allVel = BABYLON.Vector3.Zero();
            bird.cohVel = BABYLON.Vector3.Zero();
            bird.predVel = BABYLON.Vector3.Zero();

            //predator velocity
            if(bird.name == "predator"){
                nearestNeighbor(bird,cells[bird.index],bird.target);
                var t = bird.target.values().next().value; //brutto hack per ottenere elemento da set
                //bird.target = boids[1].position;
                if(t != undefined){
                    var s = new BABYLON.Vector3();
                    t.position.subtractToRef(bird.position,s);
                    s.normalize();
                    bird.speed.addInPlace(s);
                }else{
                    bird.speed.addInPlace(new BABYLON.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5))
                }
            }

            else{//if not a predator

                //avoid birds from going too far by pulling them to center
                if(centerpull && bird.name != "predator"){
                    bird.dist2center = bird.position.length();
                    bird.pullForce = new BABYLON.Vector3.Zero();
                    if (bird.dist2center > worldSize * 0.8){
        				bird.pullForce.addInPlace(bird.position);
        				bird.pullForce.normalize();

                        bird.pullForce.scaleInPlace(0.1 * bird.dist2center/(worldSize / 1.41421));//max distance in the cube
                        bird.speed.subtractInPlace(bird.pullForce);
                    }
                }

                //compute forces for each neighbor
                var neighborhood = computeNeighborhood(bird);
                for(let other of neighborhood){
                    if(other == undefined) continue;
    				var dist2 = BABYLON.Vector3.DistanceSquared(bird.position,other.position);

    				if(bird != other && dist2 <= range2 /*&& bird.position.z < other.position.z*/){
                        //inverse distance use for fall-off
                        var d = 1 / dist2;

                        //predator scare
                        if(other.name == "predator"){
                            //console.log(bird.name + " i'm attached!");
                            bird.predVel = other.position.subtract(bird.position);
                            bird.predVel.multiplyByFloats(d,d,d);
                            bird.predVel.normalize();
                            bird.predVel.scaleInPlace(-0.9);
                            bird.speed.addInPlace(bird.predVel);
                            continue;
                        }

                        //if not predator
                        else{
                            bird.neighborCount++;

                            //cohesion
                            var c = other.position;
                            //scale cohesion by distance squared
                            c.multiplyByFloats(dist2 + 1, dist2 + 1, dist2 + 1);
                            bird.cohVel.addInPlace(c);

                            //allignment
                            if (dist2<range2*.6) {
                                var a = other.speed;
                                a.multiplyByFloats(d,d,d);
                                bird.allVel.addInPlace(a);
                            }

                            //separation
        					if(dist2 <= range2*.3){
                                var s = new BABYLON.Vector3(0,0,0);
                                other.position.subtractToRef(bird.position,s);
                                s.multiplyByFloats(d,d,d);
                                bird.sepVel.addInPlace(s);
                            }
    					}
    				}
    			}

                //only update if velocity was influenced
    			if(bird.neighborCount > 0){
    				var n = 1 / bird.neighborCount;

    				bird.allVel.scaleInPlace(n);
    				bird.allVel.normalize();

                    bird.cohVel.scaleInPlace(n);
    				bird.cohVel.subtractInPlace(bird.position);
    				bird.cohVel.normalize();

                    bird.sepVel.scaleInPlace(-1 * n);
    				bird.sepVel.normalize();

                    //rules weigth scaling
                    bird.sepVel.scaleInPlace(separationMultiplier);
                    //cohesion decrease if high separation
                    bird.cohVel.scaleInPlace(cohesionMultiplier);// - bird.sepVel.length());
                    bird.allVel.scaleInPlace(allignmentMultiplier);


    				bird.speed = bird.speed.add(bird.cohVel);
    				bird.speed = bird.speed.add(bird.allVel);
    				bird.speed = bird.speed.add(bird.sepVel);
    				//bird.speed.normalize();
    			    //bird.speed.scaleInPlace(speedMultiplyer);
    			}
                if (bird.neighborCount = 0){
                    var s = new BABYLON.Vector3(Math.random() - 0.5,Math.random() - 0.5,Math.random() - 0.5);
                    bird.speed.addInPlace(s);//bird.speed = s.multiplyByFloats(2,2,2);
                }
			}
			// rotation : steer like velocity vector
			// get axis1 orthogonal to velocity
			if (bird.speed.x != 0 || bird.speed.z != 0) {
			  // velocity not collinear with Y
			  BABYLON.Vector3.CrossToRef(bird.speed, BABYLON.Axis.Y, bird.axis1);
			} else
			if (bird.speed.y != 0 || bird.speed.z != 0) {
			  // speed not collinear with X
			  BABYLON.Vector3.CrossToRef(bird.speed, BABYLON.Axis.X, bird.axis1);
			} else
			if (bird.speed.x != 0 || bird.speed.y != 0) {
			  // velocity not collinear with Z
			  BABYLON.Vector3.CrossToRef(bird.speed, BABYLON.Axis.Z, bird.axis1);
				  }
			// get axis3 orthogonal to axis1 and velocity
			BABYLON.Vector3.CrossToRef(bird.axis1, bird.speed, bird.axis3);
			BABYLON.Vector3.RotationFromAxisToRef(bird.axis1, bird.speed, bird.axis3, bird.rot);

            //speed limiter
            if(bird.name=="predator"){limitSpeed(bird)}
            else{limitSpeed(bird);}
            //bird.speed.scaleInPlace(speedMultiplyer);

		}
	}

    function clampPosition(position){
        var diff = Math.abs(position) - 250;
        if(position > 250){
            position = -250 + diff;
        }
        if(position < -250){
            position = 250 - diff;
        }
        return position
    }

    //position update function
	function updatePosition(flock){
	 	//flock.forEach(function(entry){
        for(let entry of flock){
        //update position, could use Vector3.add();
        entry.position.addInPlace(entry.speed);
        //the world is an infinite torus
        entry.position.x = clampPosition(entry.position.x);
        entry.position.y = clampPosition(entry.position.y);
        entry.position.z = clampPosition(entry.position.z);
        //update cells
        if(spatialHashing(entry) != entry.index){
            updateHashing(entry);
        }

        //rotation?
        entry.rotation = entry.rot;
        }
	};


    //birdgeometry for each "sphere"
    function updateBirdGeometry(mesh){
        var positions = [
             0,-5, 0,
             0, 5, 0,
            -2,-5, 0,
            -3,-5, 5,
            -3,-5,-5,
            -0, 3, 0,
             0,-5, 0,
        ];

        var indices = [];
        indices.push(6, 5, 4); // connect vertices 2->5->7
        indices.push(6, 5, 3); // connect vertices 2->7->1
        indices.push(0, 1, 2); // connect vertices 2->4->5
        indices.push(4, 5, 6); // connect vertices 2->3->4
        indices.push(2, 1, 0); // connect vertices 3->1->0
        indices.push(3, 5, 6); // connect vertices 3->2->1

        var normals = [
            0, 1, 0,        // 0
            0, 1, 0,        // 1
            0, 1, 0,        // 2
            0, 1, 0,        // 3
            0, 1, 0,        // 4
            0, 1, 0,        // 5
            0, 1, 0,        // 6
        ];
        var colors = [
            1, 1, 1,        // 0
            1, 1, 1,        // 1
            0, 0, 1,        // 2
            1, 1, 0,        // 3
            1, 0, 1,        // 4
            1, 1, 1,        // 5
            0, 0, 0,        // 6
        ];
        var uvs = [
            1.0, 0.0,       // 0
            1.0, 0.0,       // 1
            1.0, 0.0,       // 2
            1.0, 0.0,       // 3
            1.0, 0.0,       // 4
            1.0, 0.0,       // 5
            1.0, 0.0,       // 6
        ];
        var uv2s = [
            1.0, 0.0,       // 0
            1.0, 0.0,       // 1
            1.0, 0.0,       // 2
            1.0, 0.0,       // 3
            1.0, 0.0,       // 4
            1.0, 0.0,       // 5
            1.0, 0.0,       // 6
        ];
        var vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        vertexData.normals = normals;
        vertexData.applyToMesh(mesh, 1);
    }

	// Now, call the createScene function that you just finished creating
	var scene = createScene();

    // Register a render loop to repeatedly render the scene
  engine.runRenderLoop(function () {
      scene.render();
	});

	// Watch for browser/canvas resize events
	window.addEventListener("resize", function () {
        engine.resize();
	});

	//buttons
	var reset = document.querySelector("#reset");

    //reset button's function
	reset.addEventListener('click', function() {
		;
		SIZE = sizeSlider.value;

        //var predatorMaterial = boids["predator"];

        boids.forEach(function(entry){
	 		entry.dispose(); //remove boids
	 	});

	 	boids = [];
        createBoids(scene);
        createPredators(scene);
	}, false);


    function pullSwitch(){
        var checkbox = document.getElementById("pull");
        if(checkbox.checked){centerpull = true}
        if(!checkbox.checked){centerpull = false}
    }


    function toggle(id){
        var div = document.getElementById(id);
        div.style.display   = div.style.display == "none" ? "inline-block" : "none";
    }

    function createCells(){
        var cellsize = 50;
        var numberOfCells = worldSize * 2 / cellsize;
        var cells = [];
        //create cells once for each axis
        for( i = 0; i < numberOfCells ** 3; i++){
            cells[i] = new Set();
        }
        return cells;
    }

    function spatialHashing(boidPosition){
        var index = 0;
        index += Math.floor( (boidPosition.x + 250) / 50);
        index += Math.floor( (boidPosition.z + 250) / 50) * 10;
        index += Math.floor( (boidPosition.y + 250) / 50) * 100;

        return index;
    }

    function updateHashing(boid){
        //if(boid.index < 0 || boid.index > 999){ console.log("index of " + boid.name + " wrong: " + boid.index.toString())}
        cells[boid.index].delete(boid);

        boid.index = spatialHashing(boid.position);
        //if(boid.index < 0 || boid.index > 999){ console.log("index of " + boid.name + " wrong: " + boid.index.toString())}

        cells[boid.index].add(boid);
    }

   </script>
</body>
</html>
